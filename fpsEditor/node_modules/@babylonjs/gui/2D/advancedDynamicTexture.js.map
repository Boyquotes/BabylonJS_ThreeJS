{"version":3,"file":"advancedDynamicTexture.js","sourceRoot":"","sources":["../../../../../lts/gui/generated/2D/advancedDynamicTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { PointerInfoPre, PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { ClipboardEventTypes, ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport type { KeyboardInfoPre } from \"core/Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"core/Events/keyboardEvents\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Layer } from \"core/Layers/layer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Container } from \"./controls/container\";\r\nimport { Control } from \"./controls/control\";\r\nimport { IFocusableControl } from \"./controls/focusableControl\";\r\nimport { Style } from \"./style\";\r\nimport { Measure } from \"./measure\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IPointerEvent, IWheelEvent } from \"core/Events/deviceInputEvents\";\r\nimport { RandomGUID } from \"core/Misc/guid\";\r\nimport { GetClass } from \"core/Misc/typeStore\";\r\n\r\ndeclare type StandardMaterial = import(\"core/Materials/standardMaterial\").StandardMaterial;\r\n\r\n/**\r\n * Class used to create texture to support 2D GUI elements\r\n * @see https://doc.babylonjs.com/how_to/gui\r\n */\r\nexport class AdvancedDynamicTexture extends DynamicTexture {\r\n    /** Define the Uurl to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\r\n    public static AllowGPUOptimizations = true;\r\n\r\n    /** Snippet ID if the content was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    private _isDirty = false;\r\n    private _renderObserver: Nullable<Observer<Camera>>;\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n    private _preKeyboardObserver: Nullable<Observer<KeyboardInfoPre>>;\r\n    private _pointerMoveObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>>;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _canvasPointerOutObserver: Nullable<Observer<PointerEvent>>;\r\n    private _canvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _background: string;\r\n    /** @hidden */\r\n    public _rootContainer = new Container(\"root\");\r\n    /** @hidden */\r\n    public _lastPickedControl: Control;\r\n    /** @hidden */\r\n    public _lastControlOver: { [pointerId: number]: Control } = {};\r\n    /** @hidden */\r\n    public _lastControlDown: { [pointerId: number]: Control } = {};\r\n    /** @hidden */\r\n    public _capturingControl: { [pointerId: number]: Control } = {};\r\n    /** @hidden */\r\n    public _shouldBlockPointer: boolean;\r\n    /** @hidden */\r\n    public _layerToDispose: Nullable<Layer>;\r\n    /** @hidden */\r\n    public _linkedControls = new Array<Control>();\r\n    private _isFullscreen = false;\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _idealWidth = 0;\r\n    private _idealHeight = 0;\r\n    private _useSmallestIdeal: boolean = false;\r\n    private _renderAtIdealSize = false;\r\n    private _focusedControl: Nullable<IFocusableControl>;\r\n    private _blockNextFocusCheck = false;\r\n    private _renderScale = 1;\r\n    private _rootElement: Nullable<HTMLElement>;\r\n    private _cursorChanged = false;\r\n    private _defaultMousePointerId = 0;\r\n\r\n    /** @hidden */\r\n    public _numLayoutCalls = 0;\r\n    /** Gets the number of layout calls made the last time the ADT has been rendered */\r\n    public get numLayoutCalls(): number {\r\n        return this._numLayoutCalls;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _numRenderCalls = 0;\r\n    /** Gets the number of render calls made the last time the ADT has been rendered */\r\n    public get numRenderCalls(): number {\r\n        return this._numRenderCalls;\r\n    }\r\n\r\n    /**\r\n     * Define type to string to ensure compatibility across browsers\r\n     * Safari doesn't support DataTransfer constructor\r\n     */\r\n    private _clipboardData: string = \"\";\r\n    /**\r\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\r\n     */\r\n    public onClipboardObservable = new Observable<ClipboardInfo>();\r\n    /**\r\n     * Observable event triggered each time a pointer down is intercepted by a control\r\n     */\r\n    public onControlPickedObservable = new Observable<Control>();\r\n    /**\r\n     * Observable event triggered before layout is evaluated\r\n     */\r\n    public onBeginLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the layout was evaluated\r\n     */\r\n    public onEndLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered before the texture is rendered\r\n     */\r\n    public onBeginRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the texture was rendered\r\n     */\r\n    public onEndRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\r\n     */\r\n    public premulAlpha = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\r\n     */\r\n    public applyYInversionOnUpdate = true;\r\n    /**\r\n     * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\r\n     * Useful when you want more antialiasing\r\n     */\r\n    public get renderScale(): number {\r\n        return this._renderScale;\r\n    }\r\n    public set renderScale(value: number) {\r\n        if (value === this._renderScale) {\r\n            return;\r\n        }\r\n        this._renderScale = value;\r\n        this._onResize();\r\n    }\r\n    /** Gets or sets the background color */\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n        this._background = value;\r\n        this.markAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal width used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/how_to/gui#adaptive-scaling\r\n     */\r\n    public get idealWidth(): number {\r\n        return this._idealWidth;\r\n    }\r\n    public set idealWidth(value: number) {\r\n        if (this._idealWidth === value) {\r\n            return;\r\n        }\r\n        this._idealWidth = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal height used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/how_to/gui#adaptive-scaling\r\n     */\r\n    public get idealHeight(): number {\r\n        return this._idealHeight;\r\n    }\r\n    public set idealHeight(value: number) {\r\n        if (this._idealHeight === value) {\r\n            return;\r\n        }\r\n        this._idealHeight = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\r\n     * @see https://doc.babylonjs.com/how_to/gui#adaptive-scaling\r\n     */\r\n    public get useSmallestIdeal(): boolean {\r\n        return this._useSmallestIdeal;\r\n    }\r\n    public set useSmallestIdeal(value: boolean) {\r\n        if (this._useSmallestIdeal === value) {\r\n            return;\r\n        }\r\n        this._useSmallestIdeal = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if adaptive scaling must be used\r\n     * @see https://doc.babylonjs.com/how_to/gui#adaptive-scaling\r\n     */\r\n    public get renderAtIdealSize(): boolean {\r\n        return this._renderAtIdealSize;\r\n    }\r\n    public set renderAtIdealSize(value: boolean) {\r\n        if (this._renderAtIdealSize === value) {\r\n            return;\r\n        }\r\n        this._renderAtIdealSize = value;\r\n        this._onResize();\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used when in \"ideal mode\"\r\n     * @see https://doc.babylonjs.com/how_to/gui#adaptive-scaling\r\n     * */\r\n    public get idealRatio(): number {\r\n        let rwidth: number = 0;\r\n        let rheight: number = 0;\r\n\r\n        if (this._idealWidth) {\r\n            rwidth = this.getSize().width / this._idealWidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            rheight = this.getSize().height / this._idealHeight;\r\n        }\r\n\r\n        if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\r\n            return window.innerWidth < window.innerHeight ? rwidth : rheight;\r\n        }\r\n\r\n        if (this._idealWidth) {\r\n            // horizontal\r\n            return rwidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            // vertical\r\n            return rheight;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying layer used to render the texture when in fullscreen mode\r\n     */\r\n    public get layer(): Nullable<Layer> {\r\n        return this._layerToDispose;\r\n    }\r\n    /**\r\n     * Gets the root container control\r\n     */\r\n    public get rootContainer(): Container {\r\n        return this._rootContainer;\r\n    }\r\n    /**\r\n     * Returns an array containing the root container.\r\n     * This is mostly used to let the Inspector introspects the ADT\r\n     * @returns an array containing the rootContainer\r\n     */\r\n    public getChildren(): Array<Container> {\r\n        return [this._rootContainer];\r\n    }\r\n    /**\r\n     * Will return all controls that are inside this texture\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @return all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * Will return all controls with the given type name\r\n     * @param typeName defines the type name to search for\r\n     * @returns an array of all controls found\r\n     */\r\n    public getControlsByType(typeName: string): Control[] {\r\n        return this._rootContainer.getDescendants(false, (control) => control.typeName === typeName);\r\n    }\r\n\r\n    /**\r\n     * Will return the first control with the given name\r\n     * @param name defines the name to search for\r\n     * @return the first control found or null\r\n     */\r\n    public getControlByName(name: string): Nullable<Control> {\r\n        return this._getControlByKey(\"name\", name);\r\n    }\r\n\r\n    private _getControlByKey(key: string, value: any): Nullable<Control> {\r\n        return this._rootContainer.getDescendants().find((control) => control[key as keyof Control] === value) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current focused control\r\n     */\r\n    public get focusedControl(): Nullable<IFocusableControl> {\r\n        return this._focusedControl;\r\n    }\r\n    public set focusedControl(control: Nullable<IFocusableControl>) {\r\n        if (this._focusedControl == control) {\r\n            return;\r\n        }\r\n        if (this._focusedControl) {\r\n            this._focusedControl.onBlur();\r\n        }\r\n        if (control) {\r\n            control.onFocus();\r\n        }\r\n        this._focusedControl = control;\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\r\n     */\r\n    public get isForeground(): boolean {\r\n        if (!this.layer) {\r\n            return true;\r\n        }\r\n        return !this.layer.isBackground;\r\n    }\r\n    public set isForeground(value: boolean) {\r\n        if (!this.layer) {\r\n            return;\r\n        }\r\n        if (this.layer.isBackground === !value) {\r\n            return;\r\n        }\r\n        this.layer.isBackground = !value;\r\n    }\r\n    /**\r\n     * Gets or set information about clipboardData\r\n     */\r\n    public get clipboardData(): string {\r\n        return this._clipboardData;\r\n    }\r\n    public set clipboardData(value: string) {\r\n        this._clipboardData = value;\r\n    }\r\n\r\n    /**\r\n     * If set to true, every scene render will trigger a pointer event for the GUI\r\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\r\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\r\n     * but it has a performance cost.\r\n     */\r\n    public checkPointerEveryFrame = false;\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mipmaps must be generated (false by default)\r\n     * @param samplingMode defines the texture sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     */\r\n    constructor(name: string, width = 0, height = 0, scene?: Nullable<Scene>, generateMipMaps = false, samplingMode = Texture.NEAREST_SAMPLINGMODE, invertY = true) {\r\n        super(name, { width: width, height: height }, scene, generateMipMaps, samplingMode, Constants.TEXTUREFORMAT_RGBA, invertY);\r\n        scene = this.getScene();\r\n        if (!scene || !this._texture) {\r\n            return;\r\n        }\r\n        this.applyYInversionOnUpdate = invertY;\r\n        this._rootElement = scene.getEngine().getInputElement();\r\n        this._renderObserver = scene.onBeforeCameraRenderObservable.add((camera: Camera) => this._checkUpdate(camera));\r\n        this._preKeyboardObserver = scene.onPreKeyboardObservable.add((info) => {\r\n            if (!this._focusedControl) {\r\n                return;\r\n            }\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                this._focusedControl.processKeyboard(info.event);\r\n            }\r\n            info.skipOnPointerObservable = true;\r\n        });\r\n        this._rootContainer._link(this);\r\n        this.hasAlpha = true;\r\n        if (!width || !height) {\r\n            this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\r\n            this._onResize();\r\n        }\r\n        this._texture.isReady = true;\r\n    }\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"AdvancedDynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AdvancedDynamicTexture\";\r\n    }\r\n    /**\r\n     * Function used to execute a function on all controls\r\n     * @param func defines the function to execute\r\n     * @param container defines the container where controls belong. If null the root container will be used\r\n     */\r\n    public executeOnAllControls(func: (control: Control) => void, container?: Container) {\r\n        if (!container) {\r\n            container = this._rootContainer;\r\n        }\r\n        func(container);\r\n        for (const child of container.children) {\r\n            if ((<any>child).children) {\r\n                this.executeOnAllControls(func, <Container>child);\r\n                continue;\r\n            }\r\n            func(child);\r\n        }\r\n    }\r\n\r\n    private _useInvalidateRectOptimization = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\r\n     */\r\n    public get useInvalidateRectOptimization(): boolean {\r\n        return this._useInvalidateRectOptimization;\r\n    }\r\n\r\n    public set useInvalidateRectOptimization(value: boolean) {\r\n        this._useInvalidateRectOptimization = value;\r\n    }\r\n\r\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\r\n    private _invalidatedRectangle: Nullable<Measure> = null;\r\n    /**\r\n     * Invalidates a rectangle area on the gui texture\r\n     * @param invalidMinX left most position of the rectangle to invalidate in the texture\r\n     * @param invalidMinY top most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxX right most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\r\n     */\r\n    public invalidateRect(invalidMinX: number, invalidMinY: number, invalidMaxX: number, invalidMaxY: number) {\r\n        if (!this._useInvalidateRectOptimization) {\r\n            return;\r\n        }\r\n        if (!this._invalidatedRectangle) {\r\n            this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\r\n        } else {\r\n            // Compute intersection\r\n            const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\r\n            const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\r\n            this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\r\n            this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\r\n            this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\r\n            this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Marks the texture as dirty forcing a complete update\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Helper function used to create a new style\r\n     * @returns a new style\r\n     * @see https://doc.babylonjs.com/how_to/gui#styles\r\n     */\r\n    public createStyle(): Style {\r\n        return new Style(this);\r\n    }\r\n    /**\r\n     * Adds a new control to the root container\r\n     * @param control defines the control to add\r\n     * @returns the current texture\r\n     */\r\n    public addControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.addControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a control from the root container\r\n     * @param control defines the control to remove\r\n     * @returns the current texture\r\n     */\r\n    public removeControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.removeControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Moves overlapped controls towards a position where it is not overlapping anymore.\r\n     * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\r\n     * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\r\n     * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\r\n     * @param repelFactor how much is the control repelled by other controls\r\n     */\r\n    public moveToNonOverlappedPosition(overlapGroup?: number | Control[], deltaStep = 1, repelFactor = 1) {\r\n        let controlsForGroup: Control[];\r\n        if (Array.isArray(overlapGroup)) {\r\n            controlsForGroup = overlapGroup;\r\n        } else {\r\n            const descendants = this.getDescendants(true);\r\n            // get only the controls with an overlapGroup property set\r\n            // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\r\n            controlsForGroup = overlapGroup === undefined ? descendants.filter((c) => c.overlapGroup !== undefined) : descendants.filter((c) => c.overlapGroup === overlapGroup);\r\n        }\r\n\r\n        controlsForGroup.forEach((control1) => {\r\n            let velocity = Vector2.Zero();\r\n            const center = new Vector2(control1.centerX, control1.centerY);\r\n\r\n            controlsForGroup.forEach((control2) => {\r\n                if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\r\n                    // if the two controls overlaps get a direction vector from one control's center to another control's center\r\n                    const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\r\n                    const diffLength = diff.length();\r\n\r\n                    if (diffLength > 0) {\r\n                        // calculate the velocity\r\n                        velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (velocity.length() > 0) {\r\n                // move the control along the direction vector away from the overlapping control\r\n                velocity = velocity.normalize().scale(deltaStep * (control1.overlapDeltaMultiplier ?? 1));\r\n                control1.linkOffsetXInPixels += velocity.x;\r\n                control1.linkOffsetYInPixels += velocity.y;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._rootElement = null;\r\n        scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\r\n        if (this._resizeObserver) {\r\n            scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n        }\r\n        if (this._pointerMoveObserver) {\r\n            scene.onPrePointerObservable.remove(this._pointerMoveObserver);\r\n        }\r\n        if (this._sceneRenderObserver) {\r\n            scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._preKeyboardObserver) {\r\n            scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\r\n        }\r\n        if (this._canvasPointerOutObserver) {\r\n            scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\r\n        }\r\n        if (this._canvasBlurObserver) {\r\n            scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\r\n        }\r\n        if (this._layerToDispose) {\r\n            this._layerToDispose.texture = null;\r\n            this._layerToDispose.dispose();\r\n            this._layerToDispose = null;\r\n        }\r\n        this._rootContainer.dispose();\r\n        this.onClipboardObservable.clear();\r\n        this.onControlPickedObservable.clear();\r\n        this.onBeginRenderObservable.clear();\r\n        this.onEndRenderObservable.clear();\r\n        this.onBeginLayoutObservable.clear();\r\n        this.onEndLayoutObservable.clear();\r\n        super.dispose();\r\n    }\r\n    private _onResize(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        // Check size\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        let renderWidth = engine.getRenderWidth() * this._renderScale;\r\n        let renderHeight = engine.getRenderHeight() * this._renderScale;\r\n\r\n        if (this._renderAtIdealSize) {\r\n            if (this._idealWidth) {\r\n                renderHeight = (renderHeight * this._idealWidth) / renderWidth;\r\n                renderWidth = this._idealWidth;\r\n            } else if (this._idealHeight) {\r\n                renderWidth = (renderWidth * this._idealHeight) / renderHeight;\r\n                renderHeight = this._idealHeight;\r\n            }\r\n        }\r\n        if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\r\n            this.scaleTo(renderWidth, renderHeight);\r\n            this.markAsDirty();\r\n            if (this._idealWidth || this._idealHeight) {\r\n                this._rootContainer._markAllAsDirty();\r\n            }\r\n        }\r\n        this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\r\n    }\r\n    /** @hidden */\r\n    public _getGlobalViewport(): Viewport {\r\n        const size = this.getSize();\r\n        const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\r\n\r\n        const targetX = Math.round(globalViewPort.width * (1 / this.rootContainer.scaleX));\r\n        const targetY = Math.round(globalViewPort.height * (1 / this.rootContainer.scaleY));\r\n\r\n        globalViewPort.x += (globalViewPort.width - targetX) / 2;\r\n        globalViewPort.y += (globalViewPort.height - targetY) / 2;\r\n\r\n        globalViewPort.width = targetX;\r\n        globalViewPort.height = targetY;\r\n\r\n        return globalViewPort;\r\n    }\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position\r\n     */\r\n    public getProjectedPosition(position: Vector3, worldMatrix: Matrix): Vector2 {\r\n        const result = this.getProjectedPositionWithZ(position, worldMatrix);\r\n        return new Vector2(result.x, result.y);\r\n    }\r\n\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position with Z\r\n     */\r\n    public getProjectedPositionWithZ(position: Vector3, worldMatrix: Matrix): Vector3 {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return Vector3.Zero();\r\n        }\r\n        const globalViewport = this._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\r\n        return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\r\n    }\r\n\r\n    private _checkUpdate(camera: Camera): void {\r\n        if (this._layerToDispose) {\r\n            if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (this._isFullscreen && this._linkedControls.length) {\r\n            const scene = this.getScene();\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            const globalViewport = this._getGlobalViewport();\r\n            for (const control of this._linkedControls) {\r\n                if (!control.isVisible) {\r\n                    continue;\r\n                }\r\n                const mesh = control._linkedMesh as AbstractMesh;\r\n                if (!mesh || mesh.isDisposed()) {\r\n                    Tools.SetImmediate(() => {\r\n                        control.linkWithMesh(null);\r\n                    });\r\n                    continue;\r\n                }\r\n                const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : (Vector3.ZeroReadOnly as Vector3);\r\n                const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\r\n                if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n                    control.notRenderable = true;\r\n                    continue;\r\n                }\r\n                control.notRenderable = false;\r\n\r\n                control._moveToProjectedPosition(projectedPosition);\r\n            }\r\n        }\r\n        if (!this._isDirty && !this._rootContainer.isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = false;\r\n        this._render();\r\n        this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n    }\r\n\r\n    private _clearMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    private _render(): void {\r\n        const textureSize = this.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.getContext();\r\n        context.font = \"18px Arial\";\r\n        context.strokeStyle = \"white\";\r\n\r\n        // Layout\r\n        this.onBeginLayoutObservable.notifyObservers(this);\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n        this._numLayoutCalls = 0;\r\n        this._rootContainer._layout(measure, context);\r\n        this.onEndLayoutObservable.notifyObservers(this);\r\n        this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\r\n\r\n        // Clear\r\n        if (this._invalidatedRectangle) {\r\n            this._clearMeasure.copyFrom(this._invalidatedRectangle);\r\n        } else {\r\n            this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\r\n        }\r\n        context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n        if (this._background) {\r\n            context.save();\r\n            context.fillStyle = this._background;\r\n            context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n            context.restore();\r\n        }\r\n\r\n        // Render\r\n        this.onBeginRenderObservable.notifyObservers(this);\r\n        this._numRenderCalls = 0;\r\n        this._rootContainer._render(context, this._invalidatedRectangle);\r\n        this.onEndRenderObservable.notifyObservers(this);\r\n        this._invalidatedRectangle = null;\r\n    }\r\n    /**\r\n     * @param cursor\r\n     * @hidden\r\n     */\r\n    public _changeCursor(cursor: string) {\r\n        if (this._rootElement) {\r\n            this._rootElement.style.cursor = cursor;\r\n            this._cursorChanged = true;\r\n        }\r\n    }\r\n    /**\r\n     * @param control\r\n     * @param pointerId\r\n     * @hidden\r\n     */\r\n    public _registerLastControlDown(control: Control, pointerId: number) {\r\n        this._lastControlDown[pointerId] = control;\r\n        this.onControlPickedObservable.notifyObservers(control);\r\n    }\r\n    private _doPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        if (this._isFullscreen) {\r\n            const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            const viewport = camera.viewport;\r\n            x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\r\n            y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\r\n        }\r\n        if (this._capturingControl[pointerId]) {\r\n            this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\r\n            return;\r\n        }\r\n\r\n        this._cursorChanged = false;\r\n        if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n            if (!scene.doNotHandleCursors) {\r\n                this._changeCursor(\"\");\r\n            }\r\n            if (type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._cursorChanged && !scene.doNotHandleCursors) {\r\n            this._changeCursor(\"\");\r\n        }\r\n        this._manageFocus();\r\n    }\r\n    /**\r\n     * @param list\r\n     * @param control\r\n     * @hidden\r\n     */\r\n    public _cleanControlAfterRemovalFromList(list: { [pointerId: number]: Control }, control: Control) {\r\n        for (const pointerId in list) {\r\n            if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\r\n                continue;\r\n            }\r\n            const lastControlOver = list[pointerId];\r\n            if (lastControlOver === control) {\r\n                delete list[pointerId];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param control\r\n     * @hidden\r\n     */\r\n    public _cleanControlAfterRemoval(control: Control) {\r\n        this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\r\n        this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\r\n    }\r\n\r\n    private _translateToPicking(scene: Scene, tempViewport: Viewport, pi: Nullable<PointerInfoPre>) {\r\n        const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n        const engine = scene.getEngine();\r\n        const originalCameraToUseForPointers = scene.cameraToUseForPointers;\r\n\r\n        if (!camera) {\r\n            tempViewport.x = 0;\r\n            tempViewport.y = 0;\r\n            tempViewport.width = engine.getRenderWidth();\r\n            tempViewport.height = engine.getRenderHeight();\r\n        } else {\r\n            if (camera.rigCameras.length) {\r\n                // rig camera - we need to find the camera to use for this event\r\n                const rigViewport = new Viewport(0, 0, 1, 1);\r\n                camera.rigCameras.forEach((rigCamera) => {\r\n                    // generate the viewport of this camera\r\n                    rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\r\n                    const x = scene.pointerX / engine.getHardwareScalingLevel() - rigViewport.x;\r\n                    const y = scene.pointerY / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\r\n                    // check if the pointer is in the camera's viewport\r\n                    if (x < 0 || y < 0 || x > rigViewport.width || y > rigViewport.height) {\r\n                        // out of viewport - don't use this camera\r\n                        return;\r\n                    }\r\n                    // set the camera to use for pointers until this pointer loop is over\r\n                    scene.cameraToUseForPointers = rigCamera;\r\n                    // set the viewport\r\n                    tempViewport.x = rigViewport.x;\r\n                    tempViewport.y = rigViewport.y;\r\n                    tempViewport.width = rigViewport.width;\r\n                    tempViewport.height = rigViewport.height;\r\n                });\r\n            } else {\r\n                camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\r\n            }\r\n        }\r\n\r\n        const x = scene.pointerX / engine.getHardwareScalingLevel() - tempViewport.x;\r\n        const y = scene.pointerY / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\r\n        this._shouldBlockPointer = false;\r\n        // Do picking modifies _shouldBlockPointer\r\n        if (pi) {\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            this._doPicking(x, y, pi, pi.type, pointerId, pi.event.button, (<IWheelEvent>pi.event).deltaX, (<IWheelEvent>pi.event).deltaY);\r\n            // Avoid overwriting a true skipOnPointerObservable to false\r\n            if (this._shouldBlockPointer || this._capturingControl[pointerId]) {\r\n                pi.skipOnPointerObservable = true;\r\n            }\r\n        } else {\r\n            this._doPicking(x, y, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\r\n        }\r\n        // if overridden by a rig camera - reset back to the original value\r\n        scene.cameraToUseForPointers = originalCameraToUseForPointers;\r\n    }\r\n\r\n    /** Attach to all scene events required to support pointer events */\r\n    public attach(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const tempViewport = new Viewport(0, 0, 0, 0);\r\n\r\n        this._pointerMoveObserver = scene.onPrePointerObservable.add((pi) => {\r\n            if (scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId)) {\r\n                return;\r\n            }\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            this._translateToPicking(scene, tempViewport, pi);\r\n        });\r\n        this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n\r\n    /**\r\n     * @param rawEvt\r\n     * @hidden\r\n     */\r\n    private _onClipboardCopy = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @param rawEvt\r\n     * @hidden\r\n     */\r\n    private _onClipboardCut = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @param rawEvt\r\n     * @hidden\r\n     */\r\n    private _onClipboardPaste = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Register the clipboard Events onto the canvas\r\n     */\r\n    public registerClipboardEvents(): void {\r\n        self.addEventListener(\"copy\", this._onClipboardCopy, false);\r\n        self.addEventListener(\"cut\", this._onClipboardCut, false);\r\n        self.addEventListener(\"paste\", this._onClipboardPaste, false);\r\n    }\r\n    /**\r\n     * Unregister the clipboard Events from the canvas\r\n     */\r\n    public unRegisterClipboardEvents(): void {\r\n        self.removeEventListener(\"copy\", this._onClipboardCopy);\r\n        self.removeEventListener(\"cut\", this._onClipboardCut);\r\n        self.removeEventListener(\"paste\", this._onClipboardPaste);\r\n    }\r\n    /**\r\n     * Connect the texture to a hosting mesh to enable interactions\r\n     * @param mesh defines the mesh to attach to\r\n     * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, supportPointerMove = true): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._pointerObserver = scene.onPointerObservable.add((pi) => {\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\r\n                const uv = pi.pickInfo.getTextureCoordinates();\r\n                if (uv) {\r\n                    const size = this.getSize();\r\n                    this._doPicking(\r\n                        uv.x * size.width,\r\n                        (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height,\r\n                        pi,\r\n                        pi.type,\r\n                        pointerId,\r\n                        pi.event.button,\r\n                        (<IWheelEvent>pi.event).deltaX,\r\n                        (<IWheelEvent>pi.event).deltaY\r\n                    );\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERUP) {\r\n                if (this._lastControlDown[pointerId]) {\r\n                    this._lastControlDown[pointerId]._forcePointerUp(pointerId);\r\n                }\r\n                delete this._lastControlDown[pointerId];\r\n                if (this.focusedControl) {\r\n                    const friendlyControls = this.focusedControl.keepsFocusWith();\r\n                    let canMoveFocus = true;\r\n                    if (friendlyControls) {\r\n                        for (const control of friendlyControls) {\r\n                            // Same host, no need to keep the focus\r\n                            if (this === control._host) {\r\n                                continue;\r\n                            }\r\n                            // Different hosts\r\n                            const otherHost = control._host;\r\n                            if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\r\n                                canMoveFocus = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (canMoveFocus) {\r\n                        this.focusedControl = null;\r\n                    }\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\r\n                }\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        });\r\n        mesh.enablePointerMoveEvents = supportPointerMove;\r\n        this._attachPickingToSceneRender(\r\n            scene,\r\n            () => {\r\n                const pointerId = this._defaultMousePointerId;\r\n                const pick = scene?.pick(scene.pointerX, scene.pointerY);\r\n                if (pick && pick.hit && pick.pickedMesh === mesh) {\r\n                    const uv = pick.getTextureCoordinates();\r\n                    if (uv) {\r\n                        const size = this.getSize();\r\n                        this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\r\n                    }\r\n                } else {\r\n                    if (this._lastControlOver[pointerId]) {\r\n                        this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\r\n                    }\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            },\r\n            true\r\n        );\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n    /**\r\n     * Move the focus to a specific control\r\n     * @param control defines the control which will receive the focus\r\n     */\r\n    public moveFocusToControl(control: IFocusableControl): void {\r\n        this.focusedControl = control;\r\n        this._lastPickedControl = <any>control;\r\n        this._blockNextFocusCheck = true;\r\n    }\r\n    private _manageFocus(): void {\r\n        if (this._blockNextFocusCheck) {\r\n            this._blockNextFocusCheck = false;\r\n            this._lastPickedControl = <any>this._focusedControl;\r\n            return;\r\n        }\r\n        // Focus management\r\n        if (this._focusedControl) {\r\n            if (this._focusedControl !== <any>this._lastPickedControl) {\r\n                if (this._lastPickedControl.isFocusInvisible) {\r\n                    return;\r\n                }\r\n                this.focusedControl = null;\r\n            }\r\n        }\r\n    }\r\n    private _attachPickingToSceneRender(scene: Scene, pickFunction: () => void, forcePicking: boolean) {\r\n        this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.checkPointerEveryFrame) {\r\n                return;\r\n            }\r\n            if (this._linkedControls.length > 0 || forcePicking) {\r\n                pickFunction();\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnPointerOut(scene: Scene): void {\r\n        this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add((pointerEvent) => {\r\n            if (this._lastControlOver[pointerEvent.pointerId]) {\r\n                this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\r\n            }\r\n            delete this._lastControlOver[pointerEvent.pointerId];\r\n            if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId]._forcePointerUp();\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnBlur(scene: Scene): void {\r\n        this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\r\n            Object.entries(this._lastControlDown).forEach(([, value]) => {\r\n                value._onCanvasBlur();\r\n            });\r\n            this.focusedControl = null;\r\n            this._lastControlDown = {};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the entire GUI system\r\n     * @returns an object with the JSON serialized data\r\n     */\r\n    public serializeContent(): any {\r\n        const size = this.getSize();\r\n        const serializationObject = {\r\n            root: {},\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n\r\n        this._rootContainer.serialize(serializationObject.root);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     */\r\n    public parseContent(serializedObject: any, scaleToSize?: boolean) {\r\n        this._rootContainer = Control.Parse(serializedObject.root, this) as Container;\r\n        if (scaleToSize) {\r\n            const width = serializedObject.width;\r\n            const height = serializedObject.height;\r\n            if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\r\n                this.scaleTo(width, height);\r\n            } else {\r\n                // scales the GUI to a default size if none was available in the serialized content\r\n                this.scaleTo(1920, 1080);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromSnippetAsync(snippetId: string, scaleToSize?: boolean): Promise<void> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.gui);\r\n\r\n                        this.parseContent(serializationObject, scaleToSize);\r\n                        this.snippetId = snippetId;\r\n\r\n                        resolve();\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromURLAsync(url: string, scaleToSize?: boolean): Promise<void> {\r\n        if (url === \"\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const gui = request.responseText;\r\n                        const serializationObject = JSON.parse(gui);\r\n                        this.parseContent(serializationObject, scaleToSize);\r\n\r\n                        resolve();\r\n                    } else {\r\n                        reject(\"Unable to load\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Compares two rectangle based controls for pixel overlap\r\n     * @param control1 The first control to compare\r\n     * @param control2 The second control to compare\r\n     * @returns true if overlaps, otherwise false\r\n     */\r\n    private static _Overlaps(control1: Control, control2: Control) {\r\n        return !(\r\n            control1.centerX > control2.centerX + control2.widthInPixels ||\r\n            control1.centerX + control1.widthInPixels < control2.centerX ||\r\n            control1.centerY + control1.heightInPixels < control2.centerY ||\r\n            control1.centerY > control2.centerY + control2.heightInPixels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMesh(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        onlyAlphaTesting = false,\r\n        invertY?: boolean,\r\n        materialSetupCallback: (mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean) => void = this._CreateMaterial\r\n    ): AdvancedDynamicTexture {\r\n        // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\r\n        const uniqueId = RandomGUID();\r\n        const result = new AdvancedDynamicTexture(\r\n            `AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`,\r\n            width,\r\n            height,\r\n            mesh.getScene(),\r\n            true,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            invertY\r\n        );\r\n\r\n        materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\r\n\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n\r\n    private static _CreateMaterial(mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean): void {\r\n        const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\r\n        if (!internalClassType) {\r\n            throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\r\n        }\r\n\r\n        const material: StandardMaterial = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\r\n        material.backFaceCulling = false;\r\n        material.diffuseColor = Color3.Black();\r\n        material.specularColor = Color3.Black();\r\n        if (onlyAlphaTesting) {\r\n            material.diffuseTexture = texture;\r\n            material.emissiveTexture = texture;\r\n            texture.hasAlpha = true;\r\n        } else {\r\n            material.emissiveTexture = texture;\r\n            material.opacityTexture = texture;\r\n        }\r\n        mesh.material = material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMeshTexture(mesh: AbstractMesh, width = 1024, height = 1024, supportPointerMove = true, invertY?: boolean): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in fullscreen mode.\r\n     * In this mode the texture will rely on a layer for its rendering.\r\n     * This allows it to be treated like any other layer.\r\n     * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\r\n     * LayerMask is set through advancedTexture.layer.layerMask\r\n     * @param name defines name for the texture\r\n     * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\r\n     * @param scene defines the hosting scene\r\n     * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateFullscreenUI(\r\n        name: string,\r\n        foreground: boolean = true,\r\n        scene: Nullable<Scene> = null,\r\n        sampling = Texture.BILINEAR_SAMPLINGMODE,\r\n        adaptiveScaling: boolean = false\r\n    ): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(name, 0, 0, scene, false, sampling);\r\n        // Display\r\n        const resultScene = result.getScene();\r\n        const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\r\n        layer.texture = result;\r\n        result._layerToDispose = layer;\r\n        result._isFullscreen = true;\r\n\r\n        if (adaptiveScaling && resultScene) {\r\n            const newScale = 1 / resultScene.getEngine().getHardwareScalingLevel();\r\n            result._rootContainer.scaleX = newScale;\r\n            result._rootContainer.scaleY = newScale;\r\n        }\r\n\r\n        // Attach\r\n        result.attach();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        super.scale(ratio);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        super.scaleTo(width, height);\r\n        this.markAsDirty();\r\n    }\r\n}\r\n"]}