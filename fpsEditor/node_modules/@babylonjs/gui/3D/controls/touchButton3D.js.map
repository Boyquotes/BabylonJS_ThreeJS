{"version":3,"file":"touchButton3D.js","sourceRoot":"","sources":["../../../../../../lts/gui/generated/3D/controls/touchButton3D.ts"],"names":[],"mappings":"AAAA,mEAAmE;;AAEnE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,6CAA+B;AAE7D,OAAO,EAAE,iBAAiB,EAAE,gDAAkC;AAI9D,OAAO,EAAE,UAAU,EAAE,2CAA6B;AAElD,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC;;GAEG;AACH;IAAmC,iCAAQ;IAmBvC;;;;OAIG;IACH,uBAAY,IAAa,EAAE,aAAoB;QAA/C,YACI,kBAAM,IAAI,CAAC,SAOd;QA3BO,oBAAc,GAAG,KAAK,CAAC;QACvB,+BAAyB,GAAG,CAAC,CAAC;QAE9B,qBAAe,GAAG,KAAK,CAAC;QACxB,kBAAY,GAAG,KAAK,CAAC;QACrB,2BAAqB,GAAG;YAC5B,KAAI,CAAC,SAAS,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC;QACvC,CAAC,CAAC;QAEF;;WAEG;QACI,wBAAkB,GAAG,IAAI,UAAU,EAAW,CAAC;QAUlD,KAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QAE/C,IAAI,aAAa,EAAE;YACf,KAAI,CAAC,aAAa,GAAG,aAAa,CAAC;SACtC;;IACL,CAAC;IAKD,sBAAW,kDAAuB;QAHlC;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;;;OAAA;IAMD,sBAAW,mDAAwB;QAanC;;WAEG;aACH;YACI,IAAI,IAAI,CAAC,cAAc,EAAE;gBACrB,4EAA4E;gBAC5E,IAAM,oBAAoB,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACnD,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,yBAAyB,EAAE,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,EAAE,oBAAoB,CAAC,CAAC;gBAEzH,OAAO,oBAAoB,CAAC,SAAS,EAAE,CAAC;aAC3C;YAED,OAAO,IAAI,CAAC,yBAAyB,CAAC;QAC1C,CAAC;QA9BD;;;WAGG;aACH,UAAoC,aAAsB;YACtD,IAAI,CAAC,yBAAyB,GAAG,aAAa,CAAC,SAAS,EAAE,CAAC;YAE3D,IAAI,IAAI,CAAC,cAAc,EAAE;gBACrB,IAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAEpC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC,CAAC;gBACtD,MAAM,CAAC,MAAM,EAAE,CAAC;gBAChB,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,yBAAyB,EAAE,MAAM,EAAE,IAAI,CAAC,yBAAyB,CAAC,CAAC;gBACrG,IAAI,CAAC,yBAAyB,CAAC,SAAS,EAAE,CAAC;aAC9C;QACL,CAAC;;;OAAA;IAqBD,sBAAW,wCAAa;QAJxB;;;WAGG;aACH,UAAyB,aAAmB;YAA5C,iBAyBC;;YAxBG,mHAAmH;YACnH,IAAI,IAAI,CAAC,cAAc,EAAE;gBACrB,IAAI,CAAC,cAAc,CAAC,cAAc,GAAG,KAAK,CAAC;gBAC3C,IAAI,MAAA,IAAI,CAAC,cAAc,CAAC,iBAAiB,0CAAE,KAAK,EAAE;oBAC9C,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,KAAK,GAAG,EAAE,CAAC;iBACpD;gBAED,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC,OAAO,CAAC,UAAC,IAAI;;oBAC9C,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;oBAC5B,IAAI,MAAA,IAAI,CAAC,iBAAiB,0CAAE,KAAK,EAAE;wBAC/B,IAAI,CAAC,iBAAiB,CAAC,KAAK,GAAG,EAAE,CAAC;qBACrC;gBACL,CAAC,CAAC,CAAC;aACN;YAED,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;YACpC,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC;YACvE,IAAI,CAAC,cAAc,CAAC,cAAc,GAAG,IAAI,CAAC;YAE1C,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC,OAAO,CAAC,UAAC,IAAI;gBAC9C,KAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC,OAAO,GAAG,KAAI,CAAC;gBACxD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YAC/B,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,wBAAwB,GAAG,aAAa,CAAC,OAAO,CAAC;QAC1D,CAAC;;;OAAA;IAMD,sBAAW,yCAAc;aAkBzB;YACI,OAAO,IAAI,CAAC,eAAe,CAAC;QAChC,CAAC;QAxBD;;;WAGG;aACH,UAA0B,KAAc;YACpC,IAAI,KAAK,KAAK,IAAI,CAAC,eAAe,EAAE;gBAChC,OAAO;aACV;YAED,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;YAE7B,IAAI,KAAK,EAAE;gBACP,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;aAC9D;iBAAM;gBACH,IAAI,CAAC,qBAAqB,CAAC,cAAc,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;gBAEtE,kFAAkF;gBAClF,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBACzB;aACJ;QACL,CAAC;;;OAAA;IASD,sBAAW,oCAAS;aAKpB;YACI,OAAO,IAAI,CAAC,YAAY,CAAC;QAC7B,CAAC;QAXD;;;WAGG;aACH,UAAqB,QAAiB;YAClC,IAAI,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,YAAY,KAAK,QAAQ,EAAE;gBACxD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;aAC5B;QACL,CAAC;;;OAAA;IAKS,iCAAS,GAAnB,UAAoB,QAAiB;QACjC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC7B,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAED,oGAAoG;IAC5F,qDAA6B,GAArC,UAAsC,aAAsB;QACxD,OAAO,IAAI,CAAC,qBAAqB,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC,GAAG,CAAC,CAAC;IACpG,CAAC;IAED;;;;OAIG;IACI,qCAAa,GAApB,UAAqB,UAAmB;QACpC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACtB,OAAO,CAAC,CAAC;SACZ;QACD,IAAM,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAC5G,OAAO,IAAI,CAAC,yBAAyB,GAAG,iBAAiB,CAAC;IAC9D,CAAC;IAED,oGAAoG;IAC1F,6CAAqB,GAA/B,UAAgC,cAAuB,EAAE,OAAgB;QACrE,IAAM,QAAQ,GAAG,IAAI,CAAC,wBAAwB,CAAC;QAC/C,IAAI,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE;YACzB,gEAAgE;YAChE,OAAO,OAAO,CAAC,QAAQ,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;SACpD;QACD,IAAM,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QACzC,IAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QAElD,OAAO,GAAG,GAAG,CAAC,CAAC;IACnB,CAAC;IAED;;;;;OAKG;IACI,iDAAyB,GAAhC,UAAiC,YAAoB,EAAE,gBAAyB,EAAE,sBAA8B;QAC5G,IAAI,YAAY,KAAK,iBAAiB,CAAC,WAAW,EAAE;YAChD,IAAI,CAAC,IAAI,CAAC,6BAA6B,CAAC,gBAAgB,CAAC,EAAE;gBACvD,wEAAwE;gBACxE,OAAO,iBAAiB,CAAC,WAAW,CAAC;aACxC;iBAAM;gBACH,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;gBAC3B,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,EAAE,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC,CAAC;aAC5H;SACJ;QACD,IAAI,YAAY,KAAK,iBAAiB,CAAC,SAAS,EAAE;YAC9C,IAAI,sBAAsB,IAAI,CAAC,EAAE;gBAC7B,wEAAwE;gBACxE,OAAO,iBAAiB,CAAC,WAAW,CAAC;aACxC;iBAAM;gBACH,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;aAC/B;SACJ;QAED,OAAO,YAAY,CAAC;IACxB,CAAC;IAES,oCAAY,GAAtB;QACI,OAAO,eAAe,CAAC;IAC3B,CAAC;IAED,mBAAmB;IACT,mCAAW,GAArB,UAAsB,KAAY;QAC9B,OAAO,iBAAM,WAAW,YAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED;;OAEG;IACI,+BAAO,GAAd;QACI,iBAAM,OAAO,WAAE,CAAC;QAEhB,8BAA8B;QAC9B,IAAI,CAAC,qBAAqB,CAAC,cAAc,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;QACtE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;QAEhC,IAAI,IAAI,CAAC,cAAc,EAAE;YACrB,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;SACjC;IACL,CAAC;IACL,oBAAC;AAAD,CAAC,AAtOD,CAAmC,QAAQ,GAsO1C","sourcesContent":["// Assumptions: absolute position of button mesh is inside the mesh\r\n\r\nimport { Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\nimport { Button3D } from \"./button3D\";\r\n\r\n/**\r\n * Class used to create a touchable button in 3D\r\n */\r\nexport class TouchButton3D extends Button3D {\r\n    private _collisionMesh: Mesh;\r\n\r\n    // 'front' direction. If Vector3.Zero, there is no front and all directions of interaction are accepted\r\n    private _collidableFrontDirection: Vector3;\r\n    private _isNearPressed = false;\r\n    private _interactionSurfaceHeight = 0;\r\n\r\n    private _isToggleButton = false;\r\n    private _toggleState = false;\r\n    private _toggleButtonCallback = () => {\r\n        this._onToggle(!this._toggleState);\r\n    };\r\n\r\n    /**\r\n     * An event triggered when the button is toggled. Only fired if 'isToggleButton' is true\r\n     */\r\n    public onToggleObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     * Creates a new touchable button\r\n     * @param name defines the control name\r\n     * @param collisionMesh mesh to track collisions with\r\n     */\r\n    constructor(name?: string, collisionMesh?: Mesh) {\r\n        super(name);\r\n\r\n        this.collidableFrontDirection = Vector3.Zero();\r\n\r\n        if (collisionMesh) {\r\n            this.collisionMesh = collisionMesh;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the current interaction is caused by near interaction or not\r\n     */\r\n    public get isActiveNearInteraction() {\r\n        return this._isNearPressed;\r\n    }\r\n\r\n    /**\r\n     * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction\r\n     * @param frontWorldDir the forward direction of the button\r\n     */\r\n    public set collidableFrontDirection(frontWorldDir: Vector3) {\r\n        this._collidableFrontDirection = frontWorldDir.normalize();\r\n\r\n        if (this._collisionMesh) {\r\n            const invert = TmpVectors.Matrix[0];\r\n\r\n            invert.copyFrom(this._collisionMesh.getWorldMatrix());\r\n            invert.invert();\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);\r\n            this._collidableFrontDirection.normalize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'\r\n     */\r\n    public get collidableFrontDirection() {\r\n        if (this._collisionMesh) {\r\n            // Update the front direction to reflect any rotations of the collision mesh\r\n            const transformedDirection = TmpVectors.Vector3[0];\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);\r\n\r\n            return transformedDirection.normalize();\r\n        }\r\n\r\n        return this._collidableFrontDirection;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh used for testing input collision\r\n     * @param collisionMesh the new collision mesh for the button\r\n     */\r\n    public set collisionMesh(collisionMesh: Mesh) {\r\n        // Remove the GUI3DManager's data from the previous collision mesh's reserved data store, and reset interactability\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.isNearPickable = false;\r\n            if (this._collisionMesh.reservedDataStore?.GUI3D) {\r\n                this._collisionMesh.reservedDataStore.GUI3D = {};\r\n            }\r\n\r\n            this._collisionMesh.getChildMeshes().forEach((mesh) => {\r\n                mesh.isNearPickable = false;\r\n                if (mesh.reservedDataStore?.GUI3D) {\r\n                    mesh.reservedDataStore.GUI3D = {};\r\n                }\r\n            });\r\n        }\r\n\r\n        this._collisionMesh = collisionMesh;\r\n        this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;\r\n        this._collisionMesh.isNearPickable = true;\r\n\r\n        this._collisionMesh.getChildMeshes().forEach((mesh) => {\r\n            this._injectGUI3DReservedDataStore(mesh).control = this;\r\n            mesh.isNearPickable = true;\r\n        });\r\n        this.collidableFrontDirection = collisionMesh.forward;\r\n    }\r\n\r\n    /**\r\n     * Setter for if this TouchButton3D should be treated as a toggle button\r\n     * @param value If this TouchHolographicButton should act like a toggle button\r\n     */\r\n    public set isToggleButton(value: boolean) {\r\n        if (value === this._isToggleButton) {\r\n            return;\r\n        }\r\n\r\n        this._isToggleButton = value;\r\n\r\n        if (value) {\r\n            this.onPointerUpObservable.add(this._toggleButtonCallback);\r\n        } else {\r\n            this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\r\n\r\n            // Safety check, reset the button if it's toggled on but no longer a toggle button\r\n            if (this._toggleState) {\r\n                this._onToggle(false);\r\n            }\r\n        }\r\n    }\r\n    public get isToggleButton() {\r\n        return this._isToggleButton;\r\n    }\r\n\r\n    /**\r\n     * A public entrypoint to set the toggle state of the TouchHolographicButton. Only works if 'isToggleButton' is true\r\n     * @param newState The new state to set the TouchHolographicButton's toggle state to\r\n     */\r\n    public set isToggled(newState: boolean) {\r\n        if (this._isToggleButton && this._toggleState !== newState) {\r\n            this._onToggle(newState);\r\n        }\r\n    }\r\n    public get isToggled() {\r\n        return this._toggleState;\r\n    }\r\n\r\n    protected _onToggle(newState: boolean) {\r\n        this._toggleState = newState;\r\n        this.onToggleObservable.notifyObservers(newState);\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    private _isInteractionInFrontOfButton(collidablePos: Vector3) {\r\n        return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;\r\n    }\r\n\r\n    /**\r\n     * Get the height of the touchPoint from the collidable part of the button\r\n     * @param touchPoint the point to compare to the button, in absolute position\r\n     * @returns the depth of the touch point into the front of the button\r\n     */\r\n    public getPressDepth(touchPoint: Vector3) {\r\n        if (!this._isNearPressed) {\r\n            return 0;\r\n        }\r\n        const interactionHeight = this._getInteractionHeight(touchPoint, this._collisionMesh.getAbsolutePosition());\r\n        return this._interactionSurfaceHeight - interactionHeight;\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    protected _getInteractionHeight(interactionPos: Vector3, basePos: Vector3) {\r\n        const frontDir = this.collidableFrontDirection;\r\n        if (frontDir.length() === 0) {\r\n            // The button has no front, just return the distance to the base\r\n            return Vector3.Distance(interactionPos, basePos);\r\n        }\r\n        const d = Vector3.Dot(basePos, frontDir);\r\n        const abc = Vector3.Dot(interactionPos, frontDir);\r\n\r\n        return abc - d;\r\n    }\r\n\r\n    /**\r\n     * @param providedType\r\n     * @param nearMeshPosition\r\n     * @param activeInteractionCount\r\n     * @hidden\r\n     */\r\n    public _generatePointerEventType(providedType: number, nearMeshPosition: Vector3, activeInteractionCount: number): number {\r\n        if (providedType === PointerEventTypes.POINTERDOWN) {\r\n            if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {\r\n                // Near interaction mesh is behind the button, don't send a pointer down\r\n                return PointerEventTypes.POINTERMOVE;\r\n            } else {\r\n                this._isNearPressed = true;\r\n                this._interactionSurfaceHeight = this._getInteractionHeight(nearMeshPosition, this._collisionMesh.getAbsolutePosition());\r\n            }\r\n        }\r\n        if (providedType === PointerEventTypes.POINTERUP) {\r\n            if (activeInteractionCount == 0) {\r\n                // We get the release for the down we swallowed earlier, swallow as well\r\n                return PointerEventTypes.POINTERMOVE;\r\n            } else {\r\n                this._isNearPressed = false;\r\n            }\r\n        }\r\n\r\n        return providedType;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"TouchButton3D\";\r\n    }\r\n\r\n    // Mesh association\r\n    protected _createNode(scene: Scene): TransformNode {\r\n        return super._createNode(scene);\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        // Clean up toggle observables\r\n        this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);\r\n        this.onToggleObservable.clear();\r\n\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.dispose();\r\n        }\r\n    }\r\n}\r\n"]}