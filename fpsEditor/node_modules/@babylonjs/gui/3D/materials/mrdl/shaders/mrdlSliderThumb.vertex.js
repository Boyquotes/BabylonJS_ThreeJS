// Do not edit.
import { ShaderStore } from "@babylonjs/core/Engines/shaderStore.js";
var name = "mrdlSliderThumbVertexShader";
var shader = "uniform mat4 world;\nuniform mat4 viewProjection;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef TANGENT\nattribute vec3 tangent;\n#else\nconst vec3 tangent=vec3(0.);\n#endif\nuniform float _Radius_;\nuniform float _Bevel_Front_;\nuniform float _Bevel_Front_Stretch_;\nuniform float _Bevel_Back_;\nuniform float _Bevel_Back_Stretch_;\nuniform float _Radius_Top_Left_;\nuniform float _Radius_Top_Right_;\nuniform float _Radius_Bottom_Left_;\nuniform float _Radius_Bottom_Right_;\nuniform bool _Bulge_Enabled_;\nuniform float _Bulge_Height_;\nuniform float _Bulge_Radius_;\nuniform float _Sun_Intensity_;\nuniform float _Sun_Theta_;\nuniform float _Sun_Phi_;\nuniform float _Indirect_Diffuse_;\nuniform vec4 _Albedo_;\nuniform float _Specular_;\nuniform float _Shininess_;\nuniform float _Sharpness_;\nuniform float _Subsurface_;\nuniform vec4 _Left_Color_;\nuniform vec4 _Right_Color_;\nuniform float _Reflection_;\nuniform float _Front_Reflect_;\nuniform float _Edge_Reflect_;\nuniform float _Power_;\nuniform vec4 _Sky_Color_;\nuniform vec4 _Horizon_Color_;\nuniform vec4 _Ground_Color_;\nuniform float _Horizon_Power_;\nuniform sampler2D _Reflection_Map_;\nuniform sampler2D _Indirect_Environment_;\nuniform float _Width_;\nuniform float _Fuzz_;\nuniform float _Min_Fuzz_;\nuniform float _Clip_Fade_;\nuniform float _Hue_Shift_;\nuniform float _Saturation_Shift_;\nuniform float _Value_Shift_;\nuniform vec3 _Blob_Position_;\nuniform float _Blob_Intensity_;\nuniform float _Blob_Near_Size_;\nuniform float _Blob_Far_Size_;\nuniform float _Blob_Near_Distance_;\nuniform float _Blob_Far_Distance_;\nuniform float _Blob_Fade_Length_;\nuniform float _Blob_Pulse_;\nuniform float _Blob_Fade_;\nuniform sampler2D _Blob_Texture_;\nuniform vec3 _Blob_Position_2_;\nuniform float _Blob_Near_Size_2_;\nuniform float _Blob_Pulse_2_;\nuniform float _Blob_Fade_2_;\nuniform vec3 _Left_Index_Pos_;\nuniform vec3 _Right_Index_Pos_;\nuniform vec3 _Left_Index_Middle_Pos_;\nuniform vec3 _Right_Index_Middle_Pos_;\nuniform sampler2D _Decal_;\nuniform vec2 _Decal_Scale_XY_;\nuniform bool _Decal_Front_Only_;\nuniform float _Rim_Intensity_;\nuniform sampler2D _Rim_Texture_;\nuniform float _Rim_Hue_Shift_;\nuniform float _Rim_Saturation_Shift_;\nuniform float _Rim_Value_Shift_;\nuniform float _Iridescence_Intensity_;\nuniform sampler2D _Iridescence_Texture_;\nuniform bool Use_Global_Left_Index;\nuniform bool Use_Global_Right_Index;\nuniform vec4 Global_Left_Index_Tip_Position;\nuniform vec4 Global_Right_Index_Tip_Position;\nuniform vec4 Global_Left_Thumb_Tip_Position;\nuniform vec4 Global_Right_Thumb_Tip_Position;\nuniform float Global_Left_Index_Tip_Proximity;\nuniform float Global_Right_Index_Tip_Proximity;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUV;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec4 vColor;\nvarying vec4 vExtra1;\nvarying vec4 vExtra2;\nvarying vec4 vExtra3;\nvoid Object_To_World_Pos_B162(\nvec3 Pos_Object,\nout vec3 Pos_World)\n{\nPos_World=(world*vec4(Pos_Object,1.0)).xyz;\n}\nvoid Object_To_World_Normal_B182(\nvec3 Nrm_Object,\nout vec3 Nrm_World)\n{\nNrm_World=(vec4(Nrm_Object,0.0)).xyz;\n}\nvoid Blob_Vertex_B173(\nvec3 Position,\nvec3 Normal,\nvec3 Tangent,\nvec3 Bitangent,\nvec3 Blob_Position,\nfloat Intensity,\nfloat Blob_Near_Size,\nfloat Blob_Far_Size,\nfloat Blob_Near_Distance,\nfloat Blob_Far_Distance,\nfloat Blob_Fade_Length,\nfloat Blob_Pulse,\nfloat Blob_Fade,\nout vec4 Blob_Info)\n{\nvec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);\nvec3 delta=blob-Position;\nfloat dist=dot(Normal,delta);\nfloat lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);\nfloat fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);\nfloat size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;\nvec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);\nfloat Fade=fadeValue*Intensity*Blob_Fade;\nfloat Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);\nBlob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);\n}\nvoid Blob_Vertex_B174(\nvec3 Position,\nvec3 Normal,\nvec3 Tangent,\nvec3 Bitangent,\nvec3 Blob_Position,\nfloat Intensity,\nfloat Blob_Near_Size,\nfloat Blob_Far_Size,\nfloat Blob_Near_Distance,\nfloat Blob_Far_Distance,\nfloat Blob_Fade_Length,\nfloat Blob_Pulse,\nfloat Blob_Fade,\nout vec4 Blob_Info)\n{\nvec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);\nvec3 delta=blob-Position;\nfloat dist=dot(Normal,delta);\nfloat lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);\nfloat fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);\nfloat size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;\nvec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);\nfloat Fade=fadeValue*Intensity*Blob_Fade;\nfloat Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);\nBlob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);\n}\nvoid Move_Verts_B280(\nfloat Anisotropy,\nvec3 P,\nfloat Radius,\nfloat Bevel,\nvec3 Normal_Object,\nfloat ScaleZ,\nfloat Stretch,\nout vec3 New_P,\nout vec2 New_UV,\nout float Radial_Gradient,\nout vec3 Radial_Dir,\nout vec3 New_Normal)\n{\nvec2 UV=P.xy*2.0+0.5;\nvec2 center=clamp(UV,0.0,1.0);\nvec2 delta=UV-center;\nfloat deltad=(length(delta)*2.0);\nfloat f=(Bevel+(Radius-Bevel)*Stretch)/Radius;\nfloat innerd=clamp(deltad*2.0,0.0,1.0);\nfloat outerd=clamp(deltad*2.0-1.0,0.0,1.0);\nfloat bevelAngle=outerd*3.14159*0.5;\nfloat sinb=sin(bevelAngle);\nfloat cosb=cos(bevelAngle);\nfloat beveld=(1.0-f)*innerd+f*sinb;\nfloat br=outerd;\nvec2 r2=2.0*vec2(Radius/Anisotropy,Radius);\nfloat dir=P.z<0.0001 ? 1.0 : -1.0;\nNew_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);\nNew_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);\nRadial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);\nRadial_Dir=vec3(delta*r2,0.0);\nvec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);\nNew_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;\n}\nvoid Object_To_World_Dir_B210(\nvec3 Dir_Object,\nout vec3 Normal_World,\nout vec3 Normal_World_N,\nout float Normal_Length)\n{\nNormal_World=(world*vec4(Dir_Object,0.0)).xyz;\nNormal_Length=length(Normal_World);\nNormal_World_N=Normal_World/Normal_Length;\n}\nvoid To_XYZ_B228(\nvec3 Vec3,\nout float X,\nout float Y,\nout float Z)\n{\nX=Vec3.x;\nY=Vec3.y;\nZ=Vec3.z;\n}\nvoid Conditional_Float_B243(\nbool Which,\nfloat If_True,\nfloat If_False,\nout float Result)\n{\nResult=Which ? If_True : If_False;\n}\nvoid Object_To_World_Dir_B178(\nvec3 Dir_Object,\nout vec3 Binormal_World,\nout vec3 Binormal_World_N,\nout float Binormal_Length)\n{\nBinormal_World=(world*vec4(Dir_Object,0.0)).xyz;\nBinormal_Length=length(Binormal_World);\nBinormal_World_N=Binormal_World/Binormal_Length;\n}\nvoid Pick_Radius_B219(\nfloat Radius,\nfloat Radius_Top_Left,\nfloat Radius_Top_Right,\nfloat Radius_Bottom_Left,\nfloat Radius_Bottom_Right,\nvec3 Position,\nout float Result)\n{\nbool whichY=Position.y>0.0;\nResult=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);\nResult*=Radius;\n}\nvoid Conditional_Float_B186(\nbool Which,\nfloat If_True,\nfloat If_False,\nout float Result)\n{\nResult=Which ? If_True : If_False;\n}\nvoid Greater_Than_B187(\nfloat Left,\nfloat Right,\nout bool Not_Greater_Than,\nout bool Greater_Than)\n{\nGreater_Than=Left>Right;\nNot_Greater_Than=!Greater_Than;\n}\nvoid Remap_Range_B255(\nfloat In_Min,\nfloat In_Max,\nfloat Out_Min,\nfloat Out_Max,\nfloat In,\nout float Out)\n{\nOut=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));\n}\nvoid main()\n{\nvec2 XY_Q235;\nXY_Q235=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);\nvec3 Tangent_World_Q177;\nvec3 Tangent_World_N_Q177;\nfloat Tangent_Length_Q177;\nTangent_World_Q177=(world*vec4(vec3(1,0,0),0.0)).xyz;\nTangent_Length_Q177=length(Tangent_World_Q177);\nTangent_World_N_Q177=Tangent_World_Q177/Tangent_Length_Q177;\nvec3 Normal_World_Q210;\nvec3 Normal_World_N_Q210;\nfloat Normal_Length_Q210;\nObject_To_World_Dir_B210(vec3(0,0,1),Normal_World_Q210,Normal_World_N_Q210,Normal_Length_Q210);\nfloat X_Q228;\nfloat Y_Q228;\nfloat Z_Q228;\nTo_XYZ_B228(position,X_Q228,Y_Q228,Z_Q228);\nvec3 Nrm_World_Q176;\nNrm_World_Q176=normalize((world*vec4(normal,0.0)).xyz);\nvec3 Binormal_World_Q178;\nvec3 Binormal_World_N_Q178;\nfloat Binormal_Length_Q178;\nObject_To_World_Dir_B178(vec3(0,1,0),Binormal_World_Q178,Binormal_World_N_Q178,Binormal_Length_Q178);\nfloat Anisotropy_Q179=Tangent_Length_Q177/Binormal_Length_Q178;\nfloat Result_Q219;\nPick_Radius_B219(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q219);\nfloat Anisotropy_Q203=Binormal_Length_Q178/Normal_Length_Q210;\nbool Not_Greater_Than_Q187;\nbool Greater_Than_Q187;\nGreater_Than_B187(Z_Q228,0.0,Not_Greater_Than_Q187,Greater_Than_Q187);\nvec4 Linear_Q251;\nLinear_Q251.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);\nLinear_Q251.a=_Left_Color_.a;\nvec4 Linear_Q252;\nLinear_Q252.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);\nLinear_Q252.a=_Right_Color_.a;\nvec3 Difference_Q211=vec3(0,0,0)-Normal_World_N_Q210;\nvec4 Out_Color_Q184=vec4(X_Q228,Y_Q228,Z_Q228,1);\nfloat Result_Q186;\nConditional_Float_B186(Greater_Than_Q187,_Bevel_Back_,_Bevel_Front_,Result_Q186);\nfloat Result_Q244;\nConditional_Float_B186(Greater_Than_Q187,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q244);\nvec3 New_P_Q280;\nvec2 New_UV_Q280;\nfloat Radial_Gradient_Q280;\nvec3 Radial_Dir_Q280;\nvec3 New_Normal_Q280;\nMove_Verts_B280(Anisotropy_Q179,position,Result_Q219,Result_Q186,normal,Anisotropy_Q203,Result_Q244,New_P_Q280,New_UV_Q280,Radial_Gradient_Q280,Radial_Dir_Q280,New_Normal_Q280);\nfloat X_Q248;\nfloat Y_Q248;\nX_Q248=New_UV_Q280.x;\nY_Q248=New_UV_Q280.y;\nvec3 Pos_World_Q162;\nObject_To_World_Pos_B162(New_P_Q280,Pos_World_Q162);\nvec3 Nrm_World_Q182;\nObject_To_World_Normal_B182(New_Normal_Q280,Nrm_World_Q182);\nvec4 Blob_Info_Q173;\n#if BLOB_ENABLE\nBlob_Vertex_B173(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q173);\n#else\nBlob_Info_Q173=vec4(0,0,0,0);\n#endif\nvec4 Blob_Info_Q174;\n#if BLOB_ENABLE_2\nBlob_Vertex_B174(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q174);\n#else\nBlob_Info_Q174=vec4(0,0,0,0);\n#endif\nfloat Out_Q255;\nRemap_Range_B255(0.0,1.0,0.0,1.0,X_Q248,Out_Q255);\nfloat X_Q236;\nfloat Y_Q236;\nfloat Z_Q236;\nTo_XYZ_B228(Nrm_World_Q182,X_Q236,Y_Q236,Z_Q236);\nvec4 Color_At_T_Q247=mix(Linear_Q251,Linear_Q252,Out_Q255);\nfloat Minus_F_Q237=-Z_Q236;\nfloat R_Q249;\nfloat G_Q249;\nfloat B_Q249;\nfloat A_Q249;\nR_Q249=Color_At_T_Q247.r; G_Q249=Color_At_T_Q247.g; B_Q249=Color_At_T_Q247.b; A_Q249=Color_At_T_Q247.a;\nfloat ClampF_Q238=clamp(0.0,Minus_F_Q237,1.0);\nfloat Result_Q243;\nConditional_Float_B243(_Decal_Front_Only_,ClampF_Q238,1.0,Result_Q243);\nvec4 Vec4_Q239=vec4(Result_Q243,Radial_Gradient_Q280,G_Q249,B_Q249);\nvec3 Position=Pos_World_Q162;\nvec3 Normal=Nrm_World_Q182;\nvec2 UV=XY_Q235;\nvec3 Tangent=Tangent_World_N_Q177;\nvec3 Binormal=Difference_Q211;\nvec4 Color=Out_Color_Q184;\nvec4 Extra1=Vec4_Q239;\nvec4 Extra2=Blob_Info_Q173;\nvec4 Extra3=Blob_Info_Q174;\ngl_Position=viewProjection*vec4(Position,1);\nvPosition=Position;\nvNormal=Normal;\nvUV=UV;\nvTangent=Tangent;\nvBinormal=Binormal;\nvColor=Color;\nvExtra1=Extra1;\nvExtra2=Extra2;\nvExtra3=Extra3;\n}";
// Sideeffect
ShaderStore.ShadersStore[name] = shader;
/** @hidden */
export var mrdlSliderThumbVertexShader = { name: name, shader: shader };
//# sourceMappingURL=mrdlSliderThumb.vertex.js.map