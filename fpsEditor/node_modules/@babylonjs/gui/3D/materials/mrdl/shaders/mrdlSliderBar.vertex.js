// Do not edit.
import { ShaderStore } from "@babylonjs/core/Engines/shaderStore.js";
var name = "mrdlSliderBarVertexShader";
var shader = "uniform mat4 world;\nuniform mat4 viewProjection;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef TANGENT\nattribute vec3 tangent;\n#else\nconst vec3 tangent=vec3(0.);\n#endif\nuniform float _Radius_;\nuniform float _Bevel_Front_;\nuniform float _Bevel_Front_Stretch_;\nuniform float _Bevel_Back_;\nuniform float _Bevel_Back_Stretch_;\nuniform float _Radius_Top_Left_;\nuniform float _Radius_Top_Right_;\nuniform float _Radius_Bottom_Left_;\nuniform float _Radius_Bottom_Right_;\nuniform bool _Bulge_Enabled_;\nuniform float _Bulge_Height_;\nuniform float _Bulge_Radius_;\nuniform float _Sun_Intensity_;\nuniform float _Sun_Theta_;\nuniform float _Sun_Phi_;\nuniform float _Indirect_Diffuse_;\nuniform vec4 _Albedo_;\nuniform float _Specular_;\nuniform float _Shininess_;\nuniform float _Sharpness_;\nuniform float _Subsurface_;\nuniform vec4 _Left_Color_;\nuniform vec4 _Right_Color_;\nuniform float _Reflection_;\nuniform float _Front_Reflect_;\nuniform float _Edge_Reflect_;\nuniform float _Power_;\nuniform vec4 _Sky_Color_;\nuniform vec4 _Horizon_Color_;\nuniform vec4 _Ground_Color_;\nuniform float _Horizon_Power_;\nuniform sampler2D _Reflection_Map_;\nuniform sampler2D _Indirect_Environment_;\nuniform float _Width_;\nuniform float _Fuzz_;\nuniform float _Min_Fuzz_;\nuniform float _Clip_Fade_;\nuniform float _Hue_Shift_;\nuniform float _Saturation_Shift_;\nuniform float _Value_Shift_;\nuniform vec3 _Blob_Position_;\nuniform float _Blob_Intensity_;\nuniform float _Blob_Near_Size_;\nuniform float _Blob_Far_Size_;\nuniform float _Blob_Near_Distance_;\nuniform float _Blob_Far_Distance_;\nuniform float _Blob_Fade_Length_;\nuniform float _Blob_Pulse_;\nuniform float _Blob_Fade_;\nuniform sampler2D _Blob_Texture_;\nuniform vec3 _Blob_Position_2_;\nuniform float _Blob_Near_Size_2_;\nuniform float _Blob_Pulse_2_;\nuniform float _Blob_Fade_2_;\nuniform vec3 _Left_Index_Pos_;\nuniform vec3 _Right_Index_Pos_;\nuniform vec3 _Left_Index_Middle_Pos_;\nuniform vec3 _Right_Index_Middle_Pos_;\nuniform sampler2D _Decal_;\nuniform vec2 _Decal_Scale_XY_;\nuniform bool _Decal_Front_Only_;\nuniform float _Rim_Intensity_;\nuniform sampler2D _Rim_Texture_;\nuniform float _Rim_Hue_Shift_;\nuniform float _Rim_Saturation_Shift_;\nuniform float _Rim_Value_Shift_;\nuniform float _Iridescence_Intensity_;\nuniform sampler2D _Iridescence_Texture_;\nuniform bool Use_Global_Left_Index;\nuniform bool Use_Global_Right_Index;\nuniform vec4 Global_Left_Index_Tip_Position;\nuniform vec4 Global_Right_Index_Tip_Position;\nuniform vec4 Global_Left_Thumb_Tip_Position;\nuniform vec4 Global_Right_Thumb_Tip_Position;\nuniform float Global_Left_Index_Tip_Proximity;\nuniform float Global_Right_Index_Tip_Proximity;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUV;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec4 vColor;\nvarying vec4 vExtra1;\nvarying vec4 vExtra2;\nvarying vec4 vExtra3;\nvoid Object_To_World_Pos_B12(\nvec3 Pos_Object,\nout vec3 Pos_World)\n{\nPos_World=(world*vec4(Pos_Object,1.0)).xyz;\n}\nvoid Object_To_World_Normal_B32(\nvec3 Nrm_Object,\nout vec3 Nrm_World)\n{\nNrm_World=(vec4(Nrm_Object,0.0)).xyz;\n}\nvoid Blob_Vertex_B23(\nvec3 Position,\nvec3 Normal,\nvec3 Tangent,\nvec3 Bitangent,\nvec3 Blob_Position,\nfloat Intensity,\nfloat Blob_Near_Size,\nfloat Blob_Far_Size,\nfloat Blob_Near_Distance,\nfloat Blob_Far_Distance,\nfloat Blob_Fade_Length,\nfloat Blob_Pulse,\nfloat Blob_Fade,\nout vec4 Blob_Info)\n{\nvec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);\nvec3 delta=blob-Position;\nfloat dist=dot(Normal,delta);\nfloat lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);\nfloat fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);\nfloat size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;\nvec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);\nfloat Fade=fadeValue*Intensity*Blob_Fade;\nfloat Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);\nBlob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);\n}\nvoid Blob_Vertex_B24(\nvec3 Position,\nvec3 Normal,\nvec3 Tangent,\nvec3 Bitangent,\nvec3 Blob_Position,\nfloat Intensity,\nfloat Blob_Near_Size,\nfloat Blob_Far_Size,\nfloat Blob_Near_Distance,\nfloat Blob_Far_Distance,\nfloat Blob_Fade_Length,\nfloat Blob_Pulse,\nfloat Blob_Fade,\nout vec4 Blob_Info)\n{\nvec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);\nvec3 delta=blob-Position;\nfloat dist=dot(Normal,delta);\nfloat lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);\nfloat fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);\nfloat size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;\nvec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);\nfloat Fade=fadeValue*Intensity*Blob_Fade;\nfloat Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);\nBlob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);\n}\nvoid Move_Verts_B130(\nfloat Anisotropy,\nvec3 P,\nfloat Radius,\nfloat Bevel,\nvec3 Normal_Object,\nfloat ScaleZ,\nfloat Stretch,\nout vec3 New_P,\nout vec2 New_UV,\nout float Radial_Gradient,\nout vec3 Radial_Dir,\nout vec3 New_Normal)\n{\nvec2 UV=P.xy*2.0+0.5;\nvec2 center=clamp(UV,0.0,1.0);\nvec2 delta=UV-center;\nfloat deltad=(length(delta)*2.0);\nfloat f=(Bevel+(Radius-Bevel)*Stretch)/Radius;\nfloat innerd=clamp(deltad*2.0,0.0,1.0);\nfloat outerd=clamp(deltad*2.0-1.0,0.0,1.0);\nfloat bevelAngle=outerd*3.14159*0.5;\nfloat sinb=sin(bevelAngle);\nfloat cosb=cos(bevelAngle);\nfloat beveld=(1.0-f)*innerd+f*sinb;\nfloat br=outerd;\nvec2 r2=2.0*vec2(Radius/Anisotropy,Radius);\nfloat dir=P.z<0.0001 ? 1.0 : -1.0;\nNew_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);\nNew_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);\nRadial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);\nRadial_Dir=vec3(delta*r2,0.0);\nvec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);\nNew_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;\n}\nvoid Object_To_World_Dir_B60(\nvec3 Dir_Object,\nout vec3 Normal_World,\nout vec3 Normal_World_N,\nout float Normal_Length)\n{\nNormal_World=(world*vec4(Dir_Object,0.0)).xyz;\nNormal_Length=length(Normal_World);\nNormal_World_N=Normal_World/Normal_Length;\n}\nvoid To_XYZ_B78(\nvec3 Vec3,\nout float X,\nout float Y,\nout float Z)\n{\nX=Vec3.x;\nY=Vec3.y;\nZ=Vec3.z;\n}\nvoid Conditional_Float_B93(\nbool Which,\nfloat If_True,\nfloat If_False,\nout float Result)\n{\nResult=Which ? If_True : If_False;\n}\nvoid Object_To_World_Dir_B28(\nvec3 Dir_Object,\nout vec3 Binormal_World,\nout vec3 Binormal_World_N,\nout float Binormal_Length)\n{\nBinormal_World=(world*vec4(Dir_Object,0.0)).xyz;\nBinormal_Length=length(Binormal_World);\nBinormal_World_N=Binormal_World/Binormal_Length;\n}\nvoid Pick_Radius_B69(\nfloat Radius,\nfloat Radius_Top_Left,\nfloat Radius_Top_Right,\nfloat Radius_Bottom_Left,\nfloat Radius_Bottom_Right,\nvec3 Position,\nout float Result)\n{\nbool whichY=Position.y>0.0;\nResult=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);\nResult*=Radius;\n}\nvoid Conditional_Float_B36(\nbool Which,\nfloat If_True,\nfloat If_False,\nout float Result)\n{\nResult=Which ? If_True : If_False;\n}\nvoid Greater_Than_B37(\nfloat Left,\nfloat Right,\nout bool Not_Greater_Than,\nout bool Greater_Than)\n{\nGreater_Than=Left>Right;\nNot_Greater_Than=!Greater_Than;\n}\nvoid Remap_Range_B105(\nfloat In_Min,\nfloat In_Max,\nfloat Out_Min,\nfloat Out_Max,\nfloat In,\nout float Out)\n{\nOut=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));\n}\nvoid main()\n{\nvec2 XY_Q85;\nXY_Q85=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);\nvec3 Tangent_World_Q27;\nvec3 Tangent_World_N_Q27;\nfloat Tangent_Length_Q27;\nTangent_World_Q27=(world*vec4(vec3(1,0,0),0.0)).xyz;\nTangent_Length_Q27=length(Tangent_World_Q27);\nTangent_World_N_Q27=Tangent_World_Q27/Tangent_Length_Q27;\nvec3 Normal_World_Q60;\nvec3 Normal_World_N_Q60;\nfloat Normal_Length_Q60;\nObject_To_World_Dir_B60(vec3(0,0,1),Normal_World_Q60,Normal_World_N_Q60,Normal_Length_Q60);\nfloat X_Q78;\nfloat Y_Q78;\nfloat Z_Q78;\nTo_XYZ_B78(position,X_Q78,Y_Q78,Z_Q78);\nvec3 Nrm_World_Q26;\nNrm_World_Q26=normalize((world*vec4(normal,0.0)).xyz);\nvec3 Binormal_World_Q28;\nvec3 Binormal_World_N_Q28;\nfloat Binormal_Length_Q28;\nObject_To_World_Dir_B28(vec3(0,1,0),Binormal_World_Q28,Binormal_World_N_Q28,Binormal_Length_Q28);\nfloat Anisotropy_Q29=Tangent_Length_Q27/Binormal_Length_Q28;\nfloat Result_Q69;\nPick_Radius_B69(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q69);\nfloat Anisotropy_Q53=Binormal_Length_Q28/Normal_Length_Q60;\nbool Not_Greater_Than_Q37;\nbool Greater_Than_Q37;\nGreater_Than_B37(Z_Q78,0.0,Not_Greater_Than_Q37,Greater_Than_Q37);\nvec4 Linear_Q101;\nLinear_Q101.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);\nLinear_Q101.a=_Left_Color_.a;\nvec4 Linear_Q102;\nLinear_Q102.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);\nLinear_Q102.a=_Right_Color_.a;\nvec3 Difference_Q61=vec3(0,0,0)-Normal_World_N_Q60;\nvec4 Out_Color_Q34=vec4(X_Q78,Y_Q78,Z_Q78,1);\nfloat Result_Q36;\nConditional_Float_B36(Greater_Than_Q37,_Bevel_Back_,_Bevel_Front_,Result_Q36);\nfloat Result_Q94;\nConditional_Float_B36(Greater_Than_Q37,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q94);\nvec3 New_P_Q130;\nvec2 New_UV_Q130;\nfloat Radial_Gradient_Q130;\nvec3 Radial_Dir_Q130;\nvec3 New_Normal_Q130;\nMove_Verts_B130(Anisotropy_Q29,position,Result_Q69,Result_Q36,normal,Anisotropy_Q53,Result_Q94,New_P_Q130,New_UV_Q130,Radial_Gradient_Q130,Radial_Dir_Q130,New_Normal_Q130);\nfloat X_Q98;\nfloat Y_Q98;\nX_Q98=New_UV_Q130.x;\nY_Q98=New_UV_Q130.y;\nvec3 Pos_World_Q12;\nObject_To_World_Pos_B12(New_P_Q130,Pos_World_Q12);\nvec3 Nrm_World_Q32;\nObject_To_World_Normal_B32(New_Normal_Q130,Nrm_World_Q32);\nvec4 Blob_Info_Q23;\n#if BLOB_ENABLE\nBlob_Vertex_B23(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q23);\n#else\nBlob_Info_Q23=vec4(0,0,0,0);\n#endif\nvec4 Blob_Info_Q24;\n#if BLOB_ENABLE_2\nBlob_Vertex_B24(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q24);\n#else\nBlob_Info_Q24=vec4(0,0,0,0);\n#endif\nfloat Out_Q105;\nRemap_Range_B105(0.0,1.0,0.0,1.0,X_Q98,Out_Q105);\nfloat X_Q86;\nfloat Y_Q86;\nfloat Z_Q86;\nTo_XYZ_B78(Nrm_World_Q32,X_Q86,Y_Q86,Z_Q86);\nvec4 Color_At_T_Q97=mix(Linear_Q101,Linear_Q102,Out_Q105);\nfloat Minus_F_Q87=-Z_Q86;\nfloat R_Q99;\nfloat G_Q99;\nfloat B_Q99;\nfloat A_Q99;\nR_Q99=Color_At_T_Q97.r; G_Q99=Color_At_T_Q97.g; B_Q99=Color_At_T_Q97.b; A_Q99=Color_At_T_Q97.a;\nfloat ClampF_Q88=clamp(0.0,Minus_F_Q87,1.0);\nfloat Result_Q93;\nConditional_Float_B93(_Decal_Front_Only_,ClampF_Q88,1.0,Result_Q93);\nvec4 Vec4_Q89=vec4(Result_Q93,Radial_Gradient_Q130,G_Q99,B_Q99);\nvec3 Position=Pos_World_Q12;\nvec3 Normal=Nrm_World_Q32;\nvec2 UV=XY_Q85;\nvec3 Tangent=Tangent_World_N_Q27;\nvec3 Binormal=Difference_Q61;\nvec4 Color=Out_Color_Q34;\nvec4 Extra1=Vec4_Q89;\nvec4 Extra2=Blob_Info_Q23;\nvec4 Extra3=Blob_Info_Q24;\ngl_Position=viewProjection*vec4(Position,1);\nvPosition=Position;\nvNormal=Normal;\nvUV=UV;\nvTangent=Tangent;\nvBinormal=Binormal;\nvColor=Color;\nvExtra1=Extra1;\nvExtra2=Extra2;\nvExtra3=Extra3;\n}";
// Sideeffect
ShaderStore.ShadersStore[name] = shader;
/** @hidden */
export var mrdlSliderBarVertexShader = { name: name, shader: shader };
//# sourceMappingURL=mrdlSliderBar.vertex.js.map