import { __extends } from "tslib";
import { Gizmo } from "@babylonjs/core/Gizmos/gizmo.js";
import { Epsilon } from "@babylonjs/core/Maths/math.constants.js";
import { Matrix, Quaternion, TmpVectors, Vector3 } from "@babylonjs/core/Maths/math.vector.js";
import { TransformNode } from "@babylonjs/core/Meshes/transformNode.js";
import { PivotTools } from "@babylonjs/core/Misc/pivotTools.js";
import { CornerHandle, SideHandle } from "./gizmoHandle.js";
/**
 * Gizmo to resize 2D slates
 */
var SlateGizmo = /** @class */ (function (_super) {
    __extends(SlateGizmo, _super);
    function SlateGizmo(utilityLayer) {
        var _this = _super.call(this, utilityLayer) || this;
        _this._boundingDimensions = new Vector3(0, 0, 0);
        _this._renderObserver = null;
        _this._tmpQuaternion = new Quaternion();
        _this._tmpVector = new Vector3(0, 0, 0);
        // Ordered bl, br, tr, tl
        _this._corners = [];
        // Ordered left, bottom, right, top
        _this._sides = [];
        _this._boundingBoxGizmo = {
            min: new Vector3(),
            max: new Vector3(),
        };
        /**
         * Value we use to offset handles from mesh
         */
        _this._margin = 0.35;
        _this._handleSize = 0.075;
        _this._attachedSlate = null;
        _this._existingSlateScale = new Vector3();
        /**
         * If set, the handles will increase in size based on the distance away from the camera to have a consistent screen size (Default: true)
         */
        _this.fixedScreenSize = false;
        /**
         * The distance away from the object which the draggable meshes should appear world sized when fixedScreenSize is set to true (default: 10)
         */
        _this.fixedScreenSizeDistanceFactor = 10;
        _this._createNode();
        _this.updateScale = false;
        _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {
            // Only update the bounding box if scaling has changed
            if (_this.attachedMesh && !_this._existingSlateScale.equals(_this.attachedMesh.scaling)) {
                _this.updateBoundingBox();
            }
        });
        return _this;
    }
    Object.defineProperty(SlateGizmo.prototype, "attachedSlate", {
        get: function () {
            return this._attachedSlate;
        },
        /**
         * The slate attached to this gizmo
         */
        set: function (control) {
            var _this = this;
            if (control) {
                this.attachedMesh = control.mesh;
                this.updateBoundingBox();
                this._pickedPointObserver = control._host.onPickingObservable.add(function (pickedMesh) {
                    if (_this._handleHovered && (!pickedMesh || pickedMesh.parent !== _this._handleHovered.node)) {
                        _this._handleHovered.hover = false;
                        _this._handleHovered = null;
                    }
                    if (pickedMesh && pickedMesh.parent && pickedMesh.parent.reservedDataStore && pickedMesh.parent.reservedDataStore.handle) {
                        var handle = pickedMesh.parent.reservedDataStore.handle;
                        if (handle.gizmo === _this) {
                            _this._handleHovered = handle;
                            _this._handleHovered.hover = true;
                        }
                    }
                });
            }
            else if (this._attachedSlate) {
                this._attachedSlate._host.onPickingObservable.remove(this._pickedPointObserver);
            }
            this._attachedSlate = control;
        },
        enumerable: false,
        configurable: true
    });
    SlateGizmo.prototype._createNode = function () {
        var _this = this;
        this._handlesParent = new TransformNode("handlesParent", this.gizmoLayer.utilityLayerScene);
        this._handlesParent.rotationQuaternion = Quaternion.Identity();
        var masksCorners = [
            {
                dimensions: new Vector3(-1, -1, 0),
                origin: new Vector3(1, 0, 0),
            },
            {
                dimensions: new Vector3(1, -1, 0),
                origin: new Vector3(0, 0, 0),
            },
            {
                dimensions: new Vector3(1, 1, 0),
                origin: new Vector3(0, 1, 0),
            },
            {
                dimensions: new Vector3(-1, 1, 0),
                origin: new Vector3(1, 1, 0),
            },
        ];
        for (var i = 0; i < 4; i++) {
            var corner = new CornerHandle(this, this.gizmoLayer.utilityLayerScene);
            this._corners.push(corner);
            corner.node.rotation.z = (Math.PI / 2) * i;
            corner.node.parent = this._handlesParent;
            this._assignDragBehaviorCorners(corner, function (originStart, dimensionsStart, offset, masks) { return _this._moveHandle(originStart, dimensionsStart, offset, masks, true); }, masksCorners[i]);
        }
        for (var i = 0; i < 4; i++) {
            var side = new SideHandle(this, this.gizmoLayer.utilityLayerScene);
            this._sides.push(side);
            side.node.rotation.z = (Math.PI / 2) * i;
            side.node.parent = this._handlesParent;
            this._assignDragBehaviorSides(side, i % 2 === 0 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0));
        }
        this._handlesParent.parent = this._rootMesh;
    };
    SlateGizmo.prototype._keepAspectRatio = function (vector, aspectRatio, invertDiagonal) {
        if (invertDiagonal === void 0) { invertDiagonal = false; }
        var axis = TmpVectors.Vector3[0];
        axis.copyFromFloats(aspectRatio, 1, 0).normalize();
        if (invertDiagonal) {
            axis.y *= -1;
        }
        var dot = Vector3.Dot(vector, axis);
        vector.copyFrom(axis).scaleInPlace(dot);
    };
    SlateGizmo.prototype._clampDimensions = function (vector, dimensions, mask, keepAspectRatio) {
        if (keepAspectRatio === void 0) { keepAspectRatio = false; }
        var impact = TmpVectors.Vector3[0];
        impact.copyFrom(vector).multiplyInPlace(mask);
        var clampedDimensions = TmpVectors.Vector3[1];
        clampedDimensions.copyFromFloats(Math.max(this._attachedSlate.minDimensions.x, impact.x + dimensions.x), Math.max(this._attachedSlate.minDimensions.y, impact.y + dimensions.y), 0);
        if (keepAspectRatio) {
            // Extra logic to ensure the ratio is maintained when the vector has been clamped
            var ratio = dimensions.x / dimensions.y;
            clampedDimensions.x = Math.max(clampedDimensions.x, clampedDimensions.y * ratio);
            clampedDimensions.y = Math.max(clampedDimensions.y, clampedDimensions.x / ratio);
        }
        // Calculating the real impact of vector on clamped dimensions
        impact.copyFrom(clampedDimensions).subtractInPlace(dimensions);
        vector.x = Math.sign(vector.x) * Math.abs(impact.x);
        vector.y = Math.sign(vector.y) * Math.abs(impact.y);
    };
    SlateGizmo.prototype._moveHandle = function (originStart, dimensionsStart, offset, masks, isCorner) {
        if (!this._attachedSlate) {
            return;
        }
        if (isCorner) {
            var aspectRatio = dimensionsStart.x / dimensionsStart.y;
            this._keepAspectRatio(offset, aspectRatio, masks.dimensions.x * masks.dimensions.y < 0);
        }
        this._clampDimensions(offset, dimensionsStart, masks.dimensions, isCorner);
        var offsetOriginMasked = TmpVectors.Vector3[0];
        var offsetDimensionsMasked = TmpVectors.Vector3[1];
        offsetOriginMasked.copyFrom(offset).multiplyInPlace(masks.origin);
        offsetDimensionsMasked.copyFrom(offset).multiplyInPlace(masks.dimensions);
        this._attachedSlate.origin.copyFrom(originStart).addInPlace(offsetOriginMasked);
        this._attachedSlate.dimensions.set(dimensionsStart.x + offsetDimensionsMasked.x, dimensionsStart.y + offsetDimensionsMasked.y);
    };
    SlateGizmo.prototype._assignDragBehaviorCorners = function (handle, moveFn, masks) {
        var _this = this;
        var dimensionsStart = new Vector3();
        var originStart = new Vector3();
        var dragOrigin = new Vector3();
        var toObjectFrame = new Matrix();
        var dragPlaneNormal = new Vector3();
        var projectToRef = function (position, normal, origin, ref) {
            // Projects on the plane with its normal and origin
            position.subtractToRef(origin, TmpVectors.Vector3[0]);
            var dot = Vector3.Dot(TmpVectors.Vector3[0], normal);
            TmpVectors.Vector3[1].copyFrom(normal).scaleInPlace(dot);
            TmpVectors.Vector3[0].subtractInPlace(TmpVectors.Vector3[1]);
            TmpVectors.Vector3[0].addToRef(origin, ref);
        };
        var dragStart = function (event) {
            if (_this.attachedSlate && _this.attachedMesh) {
                dimensionsStart.set(_this.attachedSlate.dimensions.x, _this.attachedSlate.dimensions.y, Epsilon);
                originStart.copyFrom(_this.attachedSlate.origin);
                dragOrigin.copyFrom(event.position);
                toObjectFrame.copyFrom(_this.attachedMesh.computeWorldMatrix(true));
                toObjectFrame.invert();
                _this.attachedSlate._followButton.isToggled = false;
                Vector3.TransformNormalToRef(Vector3.Forward(), _this.attachedMesh.getWorldMatrix(), dragPlaneNormal);
                dragPlaneNormal.normalize();
                if (_this._handleHovered) {
                    _this._handleDragged = _this._handleHovered;
                    _this._handleDragged.drag = true;
                }
            }
        };
        var dragging = function (event) {
            if (_this.attachedSlate && _this.attachedMesh) {
                projectToRef(event.position, dragPlaneNormal, dragOrigin, _this._tmpVector);
                _this._tmpVector.subtractInPlace(dragOrigin);
                Vector3.TransformNormalToRef(_this._tmpVector, toObjectFrame, _this._tmpVector);
                moveFn(originStart, dimensionsStart, _this._tmpVector, masks);
                _this.attachedSlate._positionElements();
                _this.updateBoundingBox();
            }
        };
        var dragEnd = function () {
            if (_this.attachedSlate && _this.attachedNode) {
                _this.attachedSlate._updatePivot();
                if (_this._handleDragged) {
                    _this._handleDragged.drag = false;
                    _this._handleDragged = null;
                }
            }
        };
        handle.setDragBehavior(dragStart, dragging, dragEnd);
    };
    SlateGizmo.prototype._assignDragBehaviorSides = function (handle, dragPlaneNormal) {
        var _this = this;
        var quaternionOrigin = new Quaternion();
        var dragOrigin = new Vector3();
        var directionOrigin = new Vector3();
        var worldPivot = new Vector3();
        var worldPlaneNormal = new Vector3();
        var dragStart = function (event) {
            if (_this.attachedSlate && _this.attachedMesh) {
                quaternionOrigin.copyFrom(_this.attachedMesh.rotationQuaternion);
                dragOrigin.copyFrom(event.position);
                worldPivot.copyFrom(_this.attachedMesh.getAbsolutePivotPoint());
                directionOrigin.copyFrom(dragOrigin).subtractInPlace(worldPivot).normalize();
                _this.attachedSlate._followButton.isToggled = false;
                Vector3.TransformNormalToRef(dragPlaneNormal, _this.attachedMesh.getWorldMatrix(), worldPlaneNormal);
                worldPlaneNormal.normalize();
                if (_this._handleHovered) {
                    _this._handleDragged = _this._handleHovered;
                    _this._handleDragged.drag = true;
                }
            }
        };
        var dragging = function (event) {
            if (_this.attachedSlate && _this.attachedMesh) {
                _this._tmpVector.copyFrom(event.position);
                _this._tmpVector.subtractInPlace(worldPivot);
                _this._tmpVector.normalize();
                var angle = -Vector3.GetAngleBetweenVectorsOnPlane(_this._tmpVector, directionOrigin, worldPlaneNormal);
                Quaternion.RotationAxisToRef(dragPlaneNormal, angle, _this._tmpQuaternion);
                quaternionOrigin.multiplyToRef(_this._tmpQuaternion, _this.attachedMesh.rotationQuaternion);
            }
        };
        var dragEnd = function () {
            if (_this.attachedSlate && _this.attachedNode) {
                _this.attachedSlate._updatePivot();
                if (_this._handleDragged) {
                    _this._handleDragged.drag = false;
                    _this._handleDragged = null;
                }
            }
        };
        handle.setDragBehavior(dragStart, dragging, dragEnd);
    };
    SlateGizmo.prototype._attachedNodeChanged = function (value) {
        if (value) {
            this.updateBoundingBox();
        }
    };
    /**
     * Updates the bounding box information for the gizmo
     */
    SlateGizmo.prototype.updateBoundingBox = function () {
        if (this.attachedMesh) {
            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
            // Store original parent
            var originalParent = this.attachedMesh.parent;
            this.attachedMesh.setParent(null);
            this._update();
            // Rotate based on axis
            if (!this.attachedMesh.rotationQuaternion) {
                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
            }
            // Store original position and reset mesh to origin before computing the bounding box
            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
            this._tmpVector.copyFrom(this.attachedMesh.position);
            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
            this.attachedMesh.position.set(0, 0, 0);
            // Update bounding dimensions/positions
            var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors();
            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
            this._boundingBoxGizmo.min = boundingMinMax.min;
            this._boundingBoxGizmo.max = boundingMinMax.max;
            // Update handles of the gizmo
            this._updateHandlesPosition();
            this._updateHandlesScaling();
            // Restore position/rotation values
            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
            this.attachedMesh.position.copyFrom(this._tmpVector);
            PivotTools._RestorePivotPoint(this.attachedMesh);
            // Restore original parent
            this.attachedMesh.setParent(originalParent);
            this.attachedMesh.computeWorldMatrix(true);
            this._existingSlateScale.copyFrom(this.attachedMesh.scaling);
        }
    };
    SlateGizmo.prototype._updateHandlesPosition = function () {
        var min = this._boundingBoxGizmo.min.clone();
        var max = this._boundingBoxGizmo.max.clone();
        var handleScaling = this._corners[0].node.scaling.length();
        min.x -= this._margin * handleScaling;
        min.y -= this._margin * handleScaling;
        max.x += this._margin * handleScaling;
        max.y += this._margin * handleScaling;
        var center = min.add(max).scaleInPlace(0.5);
        this._corners[0].node.position.copyFromFloats(min.x, min.y, 0);
        this._corners[1].node.position.copyFromFloats(max.x, min.y, 0);
        this._corners[2].node.position.copyFromFloats(max.x, max.y, 0);
        this._corners[3].node.position.copyFromFloats(min.x, max.y, 0);
        this._sides[0].node.position.copyFromFloats(min.x, center.y, 0);
        this._sides[1].node.position.copyFromFloats(center.x, min.y, 0);
        this._sides[2].node.position.copyFromFloats(max.x, center.y, 0);
        this._sides[3].node.position.copyFromFloats(center.x, max.y, 0);
    };
    SlateGizmo.prototype._updateHandlesScaling = function () {
        if (this._attachedSlate && this._attachedSlate.mesh) {
            var scaledWidth = this._attachedSlate.mesh.scaling.x * this._attachedSlate.dimensions.x;
            var scaledHeight = this._attachedSlate.mesh.scaling.y * this._attachedSlate.dimensions.y;
            var scale = Math.min(scaledWidth, scaledHeight) * this._handleSize;
            for (var index = 0; index < this._corners.length; index++) {
                this._corners[index].node.scaling.setAll(scale);
            }
            for (var index = 0; index < this._sides.length; index++) {
                this._sides[index].node.scaling.setAll(scale);
            }
        }
    };
    SlateGizmo.prototype._update = function () {
        _super.prototype._update.call(this);
        if (!this.gizmoLayer.utilityLayerScene.activeCamera) {
            return;
        }
        if (this._attachedSlate && this._attachedSlate.mesh) {
            if (this.fixedScreenSize) {
                this._attachedSlate.mesh.absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
                var distanceFromCamera = (this._handleSize * this._tmpVector.length()) / this.fixedScreenSizeDistanceFactor;
                for (var i = 0; i < this._corners.length; i++) {
                    this._corners[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
                }
                for (var i = 0; i < this._sides.length; i++) {
                    this._sides[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
                }
            }
            this._updateHandlesPosition();
        }
    };
    SlateGizmo.prototype.dispose = function () {
        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
        // Will dispose rootMesh and all descendants
        _super.prototype.dispose.call(this);
        for (var _i = 0, _a = this._corners; _i < _a.length; _i++) {
            var corner = _a[_i];
            corner.dispose();
        }
        for (var _b = 0, _c = this._sides; _b < _c.length; _b++) {
            var side = _c[_b];
            side.dispose();
        }
    };
    return SlateGizmo;
}(Gizmo));
export { SlateGizmo };
//# sourceMappingURL=slateGizmo.js.map